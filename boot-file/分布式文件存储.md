

# 分布式文件存储

`温心建议：建议直接使用MinIO坑少、好用`

环境：

- centerOS 系统的EC云服务器
- docker 容器
- jdk17 

## docker 安装minio

> 拉取minio的docker镜像

```bash
docker pull minio/minio
```

> 配置minio的后台访问端口和文件访问端口，后台页面登录的账号密码

```bash
docker run -it --name minio -p 9000:9000 -p 9001:9001 -d \
-v /usr/local/docker/minio/data:/data \
-v /usr/local/docker/minio/config:/root/.minio \
-e 'MINIO_ROOT_USER=admin' \
-e 'MINIO_ROOT_PASSWORD=admin123' \
minio/minio server /data --console-address ":9001" 

```

访问：http://ip:9000 账号：admin，密码：admin123 9000：API调⽤端⼝ 9001：控制台端⼝，不指定会随机⽣成。注：控制台⽤9000也能打开，最终会跳 转到9001，效果是⼀样的。

## 整合FastDFS

一、简介

- FastDFS是一个轻量级的开源分布式文件系统。
- FastDFS主要解决了大容量的文件存储和高并发访问的问题，文件存取时实现了负载均衡。
- FastDFS实现了软件方式的RAID，可以使用廉价的IDE硬盘进行存储
- 支持存储服务器在线扩容
- 支持相同内容的文件只保存一份，节约磁盘空间
- FastDFS特别适合大中型网站使用，用来存储资源文件（如：图片、文档、音频、视频等等）

二、架构说明

- Tracker：管理集群，tracker 也可以实现集群。每个 tracker 节点地位平等。收集 Storage 集群的状态。
- Storage：实际保存文件 Storage 分为多个组，每个组之间保存的文件是不同的。每个组内部可以有多个成员，

组成员内部保存的内容是一样的，组成员的地位是一致的，没有主从的概念。

![img](https://cdn.jsdelivr.net/gh/mqxu/wiki-image@master/uPic/e9cf504ace4d1114b2305e433f42c85f_987x678.png)

说明 nginx + fileid（文件路径），http访问

![img](https://cdn.jsdelivr.net/gh/mqxu/wiki-image@master/uPic/9ff57b13bbe90feed56f55e68a556e9c_935x342.png)

三、好处

1. 将文件的管理与具体业务应用解耦，可以多个应用共用一套fastDFS集群，分成不同的组
2. 图片访问，只需要将http-url交给浏览器。nginx提供访问服务。
3. 方便统一备份，一组的多个storage就是彼此的备份
4. 可以将图片浏览，文件下载的压力分散给nginx服务。应用自己专心做业务。
5. 缩略图，防盗链等等



### 使用docker安装 FastDFS

#### 安装

- 拉取镜像

```bash
docker pull delron/fastdfs
```

- 创建本机存储目录

```bash
rm -fR /home/docker/fastdfs/{tracker,storage} 
mkdir /home/docker/fastdfs/{tracker,storage}  -p
```

- 启动tracker

```bash
docker run -d \
--network=host \
--name tracker \
-v /home/docker/fastdfs/tracker:/var/fdfs \
delron/fastdfs tracker
```

- 启动storage（改成自己的地址）

```bash
docker run -d \
--network=host \
--name storage \
-e TRACKER_SERVER=47.101.62.73:22122 \
-v /home/docker/fastdfs/storage:/var/fdfs \
-e GROUP_NAME=group1  \
delron/fastdfs storage
```

#### 开启宿主机防火墙端口

morunchang/fastdfs镜像在构建的时候，为nginx配置的端口是8888（开相应安全组）

```bash
firewall-cmd --zone=public --add-port=22122/tcp --permanent
firewall-cmd --zone=public --add-port=23000/tcp --permanent
firewall-cmd --zone=public --add-port=8888/tcp --permanent
firewall-cmd --reload
# 查看是否开放
firewall-cmd --query-port=22122/tcp
firewall-cmd --query-port=23000/tcp
firewall-cmd --query-port=8888/tcp
```

#### 测试安装结果

FastDFS安装包中，自带了客户端程序，可以使用这个命令行客户端进行文件上传及下载测试。
在宿主机执行命令

- 上传文件（是容器里面的文件）

```bash
docker exec -i storage /usr/bin/fdfs_upload_file /etc/fdfs/client.conf ./README
返回结果（序号不一定一样）group1/M00/00/00/wKgBW10lZHCAC8TaAAAAMT6WPfM3645854
```

- 查看fastdfs文件系统信息

```bash
docker exec -i storage fdfs_file_info /etc/fdfs/client.conf 
group1/M00/00/00/CgAEBGJYNGSAHgoFAAAAMT6WPfM6554769
group1/M00/00/00/wKgBW10lZHCAC8TaAAAAMT6WPfM3645854
# 结果
source storage id: 0
source ip address: 192.168.1.91
file create timestamp: 2019-07-10 04:07:12
file size: 49
file crc32: 1050033651 (0x3E963DF3)
```

- 下载文件，不会下载到宿主机，要到去容器里面看（注意改成你自己的文件序号）

```
docker exec -i storage fdfs_download_file /etc/fdfs/client.conf group1/M00/00/00/wKgBW10lZHCAC8TaAAAAMT6WPfM3645854
```

3.4 查看集群状态

```bash
docker exec -i storage  fdfs_monitor /etc/fdfs/storage.conf
```



### 开发一个自定义fastdfs-starter

#### 主要实现的功能

1. 实现FastDFSClientUtil及properties的自动装配（如何开发一个自定义的spring-boot-starter）
2. 加入连接线程池管理

#### 实现FastDFSClientUtil及properties的自动装配

实际上就是要自己实现一个starter

第一步：创建项目

<img src="https://cdn.jsdelivr.net/gh/mqxu/wiki-image@master/uPic/image-20220414192457070.png" alt="1" style="zoom:50%;" />



第二步：引入maven依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.mqxu.boot</groupId>
  <artifactId>mqxu-fastdfs-spring-boot-starter</artifactId>
  <version>1.0.0</version>

  <name>mqxu-fastdfs-spring-boot-starter</name>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>17</maven.compiler.source>
    <maven.compiler.target>17</maven.compiler.target>
  </properties>

  <parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.6.4</version>
  </parent>


  <dependencies>

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-configuration-processor</artifactId>
      <optional>true</optional>
    </dependency>

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-autoconfigure</artifactId>
    </dependency>

   <dependency>
      <groupId>net.oschina.zcx7878</groupId>
      <artifactId>fastdfs-client-java</artifactId>
      <version>1.27.0.0</version>
    </dependency>

    <dependency>
      <groupId>org.apache.commons</groupId>
      <artifactId>commons-pool2</artifactId>
    </dependency>

  </dependencies>
</project>

```

其中 spring-boot-configuration-processor 的作用是编译时生成spring-configuration-metadata.json， 此文件主要给IDE使用，用于提示。

fastdfs-client-java和commons-pool2 是实现fastdfs功能及连接池的，与自动装配无关。



第三步：FastDFS属性类 FastDFSProperties

```java
package com.mqxu.boot.fastdfs;


import org.springframework.boot.context.properties.ConfigurationProperties;

import java.util.ArrayList;
import java.util.List;

@ConfigurationProperties(prefix = "mqxu.fastdfs")
public class FastDFSProperties {

    private Integer connect_timeout = 5;
    private Integer network_timeout = 30;
    private String charset = "UTF-8";
    private List<String> tracker_server = new ArrayList<>();
    private Integer max_total;
    private Boolean http_anti_steal_token = false;
    private String http_secret_key = "";
    private Integer http_tracker_http_port = 8987;
    //下面这个实际上不是fastdfs的属性，为了方便实用自定义属性，表示访问nginx的http地址
    private String httpserver;

    public Integer getHttp_tracker_http_port() {
        return http_tracker_http_port;
    }

    public void setHttp_tracker_http_port(Integer http_tracker_http_port) {
        this.http_tracker_http_port = http_tracker_http_port;
    }

    public Boolean getHttp_anti_steal_token() {
        return http_anti_steal_token;
    }

    public void setHttp_anti_steal_token(Boolean http_anti_steal_token) {
        this.http_anti_steal_token = http_anti_steal_token;
    }

    public String getHttp_secret_key() {
        return http_secret_key;
    }

    public void setHttp_secret_key(String http_secret_key) {
        this.http_secret_key = http_secret_key;
    }

    public Integer getMax_total() {
        return max_total;
    }

    public void setMax_total(Integer max_total) {
        this.max_total = max_total;
    }

    public String getHttpserver() {
        return httpserver;
    }

    public void setHttpserver(String httpserver) {
        this.httpserver = httpserver;
    }

    public List<String> getTracker_server() {
        return tracker_server;
    }

    public void setTracker_server(List<String> tracker_server) {
        this.tracker_server = tracker_server;
    }

    public Integer getConnect_timeout() {
        return connect_timeout;
    }

    public void setConnect_timeout(Integer connect_timeout) {
        this.connect_timeout = connect_timeout;
    }

    public Integer getNetwork_timeout() {
        return network_timeout;
    }

    public void setNetwork_timeout(Integer network_timeout) {
        this.network_timeout = network_timeout;
    }

    public String getCharset() {
        return charset;
    }

    public void setCharset(String charset) {
        this.charset = charset;
    }
}
```

其余如Base64工具类、FastDFSClient、FastDFSClientFactory、FastDFSClientPool等查看代码

第四步：自动装配配置类

```java
package com.mqxu.boot.fastdfs;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;


/**
 * 实现最终目标把FastDFSClientUtil自动注入Spring，提供外部使用
 */
@Configuration
//当classpath下面有这三个类才做自动装配
@ConditionalOnClass(value = {FastDFSClientFactory.class,FastDFSClientPool.class,FastDFSClientUtil.class,})
//@EnableConfigurationProperties 相当于把使用 @ConfigurationProperties的类注入。
@EnableConfigurationProperties(FastDFSProperties.class)
public class AutoConfigure {

    private final FastDFSProperties properties;

    @Autowired
    public AutoConfigure(FastDFSProperties properties) {
        this.properties = properties;
    }

    @Bean
    FastDFSClientPool fastDFSClientPool(){
        return new FastDFSClientPool(properties);
    }

    @Bean
    @ConditionalOnMissingBean  //当没有FastDFSClientUtil，就把FastDFSClientUtil作为Bean注入Spring
    FastDFSClientUtil fastDFSClientUtil (){
        return  new FastDFSClientUtil(properties);
    }

}
```



第五步：在resources/META-INF/下创建spring.factories文件

```java
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.mqxu.boot.fastdfs.AutoConfigure
```



#### 总结Starter的工作原理

- Spring Boot在启动时扫描项目所依赖的JAR包，寻找包含spring.factories文件的JAR包
- 根据spring.factories配置加载AutoConfigure类
- 根据 @Conditional 注解的条件，进行自动配置并将Bean注入Spring Context



#### 打包安装

依次执行 mvn clean、mvn install 命令，在本地仓库安装成功

<img src="https://cdn.jsdelivr.net/gh/mqxu/wiki-image@master/uPic/image-20220414192918144.png" alt="23" style="zoom:50%;" />



### 整合fastDFS操作文件数据

- 在需要上传文件的项目中引入maven依赖坐标

```xml
<dependency>
    <groupId>com.mqxu.boot</groupId>
    <artifactId>mqxu-fastdfs-spring-boot-starter</artifactId>
    <version>1.0.0</version>
</dependency>
```



- 写配置

```yaml
mqxu:
  fastdfs:
    httpserver: http://47.96.31.161:8888/ # 在使用FastDFSClientUtil会得到完整的http文件访问路径
    connect_timeout: 5
    network_timeout: 30
    charset: UTF-8
    tracker_server: # tracker_server 可以配置成数组
      - 47.96.31.161:22122
    max_total: 50
    http_anti_steal_token: false # 如果有防盗链的话，这里true
    http_secret_key: # 有防盗链，这里填secret_key
```



- 写上传接口

```java
@RestController
@RequestMapping(value = "fastdfs")
public class FastDfsController {
    @Resource
    private FastDFSClientUtil fastDFSClientUtil;

    @PostMapping("/upload")
    public AjaxResponse upload(@RequestParam("file") MultipartFile file) {
        String fileId;
        try {
            String originalFileName = file.getOriginalFilename();
            assert originalFileName != null;
            fileId = fastDFSClientUtil.uploadFile(file.getBytes(),originalFileName.substring(originalFileName.lastIndexOf(".")));
            return AjaxResponse.success(fastDFSClientUtil.getSourceUrl(fileId));
        } catch (Exception e) {
            throw new CustomException(CustomExceptionType.SYSTEM_ERROR,"文件上传图片服务器失败");
        }
    }

}
```



- postman测试

![image-20220414193157219](https://cdn.jsdelivr.net/gh/mqxu/wiki-image@master/uPic/image-20220414193157219.png)



访问返回的图片地址，可以成功访问到上传的图片

![image-20220414193233482](https://cdn.jsdelivr.net/gh/mqxu/wiki-image@master/uPic/image-20220414193233482.png)
