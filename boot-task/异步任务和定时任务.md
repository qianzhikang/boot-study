# 异步任务和定时任务

## 实现异步任务

### 异步调用

> 首先创建一个任务类，作为业务的逻辑的模拟：

```java
public abstract class AbstractTask {
    private static final Random random = new Random();
    public void doTaskOne() throws Exception {
        System.out.println("开始做任务一");
        long start = currentTimeMillis();
        sleep(random.nextInt(10000));
        long end = currentTimeMillis();
        System.out.println("完成任务一，耗时" + (end - start) + "毫秒");
    }

    public void doTaskTwo() throws Exception {
        System.out.println("开始做任务二");
        long start = currentTimeMillis();
        sleep(random.nextInt(10000));
        long end = currentTimeMillis();
        System.out.println("完成任务二，耗时" + (end - start) + "毫秒");
    }

    public void doTaskThree() throws Exception {
        System.out.println("开始做任务三");
        long start = currentTimeMillis();
        sleep(random.nextInt(10000));
        long end = currentTimeMillis();
        System.out.println("完成任务三，耗时" + (end - start) + "毫秒");
    }
}

```

> 在启动类开启异步任务

![image-20220412203746905](https://pic-go.oss-cn-shanghai.aliyuncs.com/typora-img/202204122037959.png)

> 写一个异步类继承任务类，调用任务并加上异步注解@Async

```java
@Component
public class AsyncTask extends AbstractTask{
    @Override
    @Async //异步注解，不允许加在static方法上面
    public void doTaskOne() throws Exception {
        super.doTaskOne();
    }

    @Override
    @Async
    public void doTaskTwo() throws Exception {
        super.doTaskTwo();
    }

    @Override
    @Async
    public void doTaskThree() throws Exception {
        super.doTaskThree();
    }
}
```

> 测试

```java
@SpringBootTest
@ExtendWith(SpringExtension.class)
class AsyncTaskTest {
    @Resource
    AsyncTask asyncTask;
    @Test
    void doTaskAsync() throws Exception {
        asyncTask.doTaskOne();
        asyncTask.doTaskTwo();
        asyncTask.doTaskThree();
    }
}
```

> 结果

![image-20220412204408653](https://pic-go.oss-cn-shanghai.aliyuncs.com/typora-img/202204122044702.png)

并没有得到任务的执行时间等信息，这是因为异步任务中任务开始不再关心异步任务执行是否完毕，主线程程序执行完毕之后就执行完毕停止运行了，想要拿到这些线程中的执行消息，需要使用带**回调**的异步线程，来拿到线程是否执行完毕的信息。

### 异步回调

> 创建带回调的异步任务，来实现获取异步线程中执行的信息。

```java
@Component
public class AsyncCallBackTask extends AbstractTask{

    @Async
    public Future<String> doTaskOneCallback() throws Exception {
        super.doTaskOne();
        return new AsyncResult<>("任务一完成");
    }

    @Async
    public Future<String> doTaskTwoCallback() throws Exception {
        super.doTaskTwo();
        return new AsyncResult<>("任务二完成");
    }

    @Async
    public Future<String> doTaskThreeCallback() throws Exception {
        super.doTaskThree();
        return new AsyncResult<>("任务三完成");
    }

}
```

> 创建测试，使用while循环等待所有线程执行完毕，再停止主线程工作。

```java
@SpringBootTest
@ExtendWith(SpringExtension.class)
class AsyncCallBackTaskTest {

    @Resource
    AsyncCallBackTask asyncCallBackTask;

    @Test
    void doTaskOneCallback() throws Exception {
        Future<String> stringFuture1 = asyncCallBackTask.doTaskOneCallback();
        Future<String> stringFuture2 = asyncCallBackTask.doTaskTwoCallback();
        Future<String> stringFuture3 = asyncCallBackTask.doTaskThreeCallback();

        while(!stringFuture1.isDone()||!stringFuture2.isDone()||!stringFuture3.isDone()){
            sleep(1000);
        }
    }
}
```

> 结果

![image-20220412205840143](https://pic-go.oss-cn-shanghai.aliyuncs.com/typora-img/202204122058187.png)

## 线程池

### 线程池的作用

- 防止资源占用无限扩张
- 调用过程省去资源的创建和销毁占用的时间

### 自定义线程池

#### 方式1：yml配置文件

![image-20220412211452173](https://pic-go.oss-cn-shanghai.aliyuncs.com/typora-img/202204122114212.png)**各个字段的具体含义如下：**

![](https://pic-go.oss-cn-shanghai.aliyuncs.com/typora-img/202204122115998.jpg)



#### 方式2：JavaBean配置

```java
package com.qzk.boot.config;

import org.springframework.context.annotation.Bean;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;
import org.springframework.stereotype.Component;

import java.util.concurrent.Executor;
import java.util.concurrent.ThreadPoolExecutor;

/**
 * @Description TODO
 * @Date 2022-04-12-21-03
 * @Author Courage
 */
@Component
public class TaskConfiguration {

    @Bean("taskExecutor")
    public Executor taskExecutor(){
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(8);
        executor.setMaxPoolSize(16);
        executor.setKeepAliveSeconds(60);
        executor.setAllowCoreThreadTimeOut(true);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("taskExecutor");
        return executor;
    }
}

```



> 调用自定义线程池，执行异步任务
>
> 在@Async中注明使用的线程池bean

```java
package com.qzk.boot.task;

import org.springframework.scheduling.annotation.Async;
import org.springframework.scheduling.annotation.AsyncResult;
import org.springframework.stereotype.Component;

import java.util.concurrent.Future;

/**
 * @Description TODO
 * @Date 2022-04-12-21-08
 * @Author Courage
 */
@Component
public class AsyncExecutorTask extends AbstractTask{
    @Async("taskExecutor")
    public Future<String> doTaskOneCallback() throws Exception {
        super.doTaskOne();
        System.out.println("任务一，当前线程：" + Thread.currentThread().getName());
        return new AsyncResult<>("任务一完成");
    }
    @Async("taskExecutor")
    public Future<String> doTaskTwoCallback() throws Exception {
        super.doTaskTwo();
        System.out.println("任务二，当前线程：" + Thread.currentThread().getName());
        return new AsyncResult<>("任务二完成");
    }
    @Async("taskExecutor")
    public Future<String> doTaskThreeCallback() throws Exception {
        super.doTaskThree();
        System.out.println("任务三，当前线程：" + Thread.currentThread().getName());
        return new AsyncResult<>("任务三完成");
    }
}

```

> 测试：

```java
@SpringBootTest
@ExtendWith(SpringExtension.class)
class AsyncExecutorTaskTest {

    @Resource
    AsyncExecutorTask asyncExecutorTask;
    @Test
    void doTask() throws Exception {
        Future<String> task1 = asyncExecutorTask.doTaskOneCallback();
        Future<String> task2 = asyncExecutorTask.doTaskTwoCallback();
        Future<String> task3 = asyncExecutorTask.doTaskThreeCallback();

        while(!task1.isDone()||!task2.isDone()||!task3.isDone()){
            sleep(1000);
        }

    }
}
```

![image-20220412212243029](https://pic-go.oss-cn-shanghai.aliyuncs.com/typora-img/202204122122078.png)

## 定时任务

使用定时任务需要开启注解：**@EnableScheduling**（定时任务也需要开启异步任务注解@EnableAsync）。

![image-20220412212635810](https://pic-go.oss-cn-shanghai.aliyuncs.com/typora-img/202204122126867.png)

> 创建定时任务

```java
@Component
public class ScheduledEmailJobs {
    @Resource
    EmailService emailService;
    @Scheduled(cron = "0/10 * * * * ?")  // 每隔十秒执行一次
    public void cronEmailJob(){
        System.out.println(“每隔十秒执行一次”);
    }
}
```



### cron表达式

cron表达式是一个字符串，该字符串由 `6` 个空格分为 `7` 个域，每一个域代表一个时间含义。通常定义 “年” 的部分可以省略，实际常用的由 前六部分组成。在springboot中，第七个参数表示的是周，范围是`1-7`。

> 具体含义：
>
> - 第一位表示`秒`,取值`0-59`
> - 第二位表示`分`,取值`0-59`
> - 第三位表示`时`,取值`0-23`
> - 第四位表示日期`天`,取值`1-31`
> - 第五位表示日期`月份`,取值`1-12`
> - 第六位表示`星期`,取值`1-7`,`1表示星期天，2表示星期一....`
> - 第七位表示`年份`，可留空，取值`1970-2099`



>一些特殊的符号
>
>- `*`星号，可以理解为每的意思，每秒，每分，每天，每月，每年....
>- `?`问号，问号只能出现在日期和星期两个位置
>- `-`减号，表示一个范围，如在小时字段字段中的 `10-12`表示`10,11,12`
>- `,`逗号，表示一个列表值
>- `/`斜杠，如 `x/y` `x`是开始值，`y`是步长，从 `x` 开始，每`y`秒执行一次



## 定时任务之quartz框架

Quartz是OpenSymphony开源组织在⼯作计划-定时任务领域的另⼀个开源项⽬。它是完全由 Java开发的，可⽤于执⾏预定任务。它类似于java.util.Timer定时器。但是与timer相⽐， quartz增加了许多功能。



### 一个简单的quartz定时任务

> 引入依赖

```xml
<!--引⼊quartz定时框架-->
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-quartz</artifactId>
</dependency>

```

> 创建⼀个任务类Job

```java
public class QuartzSimpleTask extends QuartzJobBean {
    @Override
    protected void executeInternal(JobExecutionContext jobExecutionContext)
            throws JobExecutionException {
        System.out.println("quartz简单的定时任务执⾏时间：" + new Date());
    }
}
```

> 创建 Quartz 定时配置类

```java
package com.qzk.boot.quartz;

import org.quartz.*;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @Description TODO
 * @Date 2022-04-12-21-55
 * @Author Courage
 */
@Configuration
public class QuartzSimpleConfig {
    @Bean
    public JobDetail uploadTaskDetail() {
        return JobBuilder.newJob(QuartzSimpleTask.class)
                .withIdentity("QuartzSimpleTask")
                .storeDurably()
                .build();
    }
    @Bean
    public Trigger uploadTaskTrigger() {
        //这⾥设定触发执⾏的⽅式
        CronScheduleBuilder scheduleBuilder =
                CronScheduleBuilder.cronSchedule("*/5 * * * * ?");
        // 返回任务触发器
        return TriggerBuilder.newTrigger().forJob(uploadTaskDetail())
                .withIdentity("QuartzSimpleTask")
                .withSchedule(scheduleBuilder)
                .build();
    }
}
```

> 在启动类上加上注解
>
> - @EnableAsync //开启异步任务
> - @EnableScheduling
>
> 启动项目： 可以看到每5秒执行一次

![image-20220412220317095](https://pic-go.oss-cn-shanghai.aliyuncs.com/typora-img/202204122203149.png)

### quartz动态定时任务(数据库持久化)

> 除了加入`quartz`，还需要`mybatis` 和 `mysql`的驱动依赖

```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
</dependency>
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>2.2.2</version>
</dependency>
```



> 数据库建表脚本：
>
> github地址：[quartz/tables_mysql.sql at quartz-2.3.x · quartz-scheduler/quartz · GitHub](https://github.com/quartz-scheduler/quartz/blob/quartz-2.3.x/quartz-core/src/main/resources/org/quartz/impl/jdbcjobstore/tables_mysql.sql)

```sql
CREATE TABLE QRTZ_JOB_DETAILS
  (
    SCHED_NAME VARCHAR(120) NOT NULL,
    JOB_NAME  VARCHAR(200) NOT NULL,
    JOB_GROUP VARCHAR(200) NOT NULL,
    DESCRIPTION VARCHAR(250) NULL,
    JOB_CLASS_NAME   VARCHAR(250) NOT NULL,
    IS_DURABLE VARCHAR(1) NOT NULL,
    IS_NONCONCURRENT VARCHAR(1) NOT NULL,
    IS_UPDATE_DATA VARCHAR(1) NOT NULL,
    REQUESTS_RECOVERY VARCHAR(1) NOT NULL,
    JOB_DATA BLOB NULL,
    PRIMARY KEY (SCHED_NAME,JOB_NAME,JOB_GROUP)
);

CREATE TABLE QRTZ_TRIGGERS
  (
    SCHED_NAME VARCHAR(120) NOT NULL,
    TRIGGER_NAME VARCHAR(200) NOT NULL,
    TRIGGER_GROUP VARCHAR(200) NOT NULL,
    JOB_NAME  VARCHAR(200) NOT NULL,
    JOB_GROUP VARCHAR(200) NOT NULL,
    DESCRIPTION VARCHAR(250) NULL,
    NEXT_FIRE_TIME BIGINT(13) NULL,
    PREV_FIRE_TIME BIGINT(13) NULL,
    PRIORITY INTEGER NULL,
    TRIGGER_STATE VARCHAR(16) NOT NULL,
    TRIGGER_TYPE VARCHAR(8) NOT NULL,
    START_TIME BIGINT(13) NOT NULL,
    END_TIME BIGINT(13) NULL,
    CALENDAR_NAME VARCHAR(200) NULL,
    MISFIRE_INSTR SMALLINT(2) NULL,
    JOB_DATA BLOB NULL,
    PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),
    FOREIGN KEY (SCHED_NAME,JOB_NAME,JOB_GROUP)
        REFERENCES QRTZ_JOB_DETAILS(SCHED_NAME,JOB_NAME,JOB_GROUP)
);

CREATE TABLE QRTZ_SIMPLE_TRIGGERS
  (
    SCHED_NAME VARCHAR(120) NOT NULL,
    TRIGGER_NAME VARCHAR(200) NOT NULL,
    TRIGGER_GROUP VARCHAR(200) NOT NULL,
    REPEAT_COUNT BIGINT(7) NOT NULL,
    REPEAT_INTERVAL BIGINT(12) NOT NULL,
    TIMES_TRIGGERED BIGINT(10) NOT NULL,
    PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),
    FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
        REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
);

CREATE TABLE QRTZ_CRON_TRIGGERS
  (
    SCHED_NAME VARCHAR(120) NOT NULL,
    TRIGGER_NAME VARCHAR(200) NOT NULL,
    TRIGGER_GROUP VARCHAR(200) NOT NULL,
    CRON_EXPRESSION VARCHAR(200) NOT NULL,
    TIME_ZONE_ID VARCHAR(80),
    PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),
    FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
        REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
);

CREATE TABLE QRTZ_SIMPROP_TRIGGERS
  (
    SCHED_NAME VARCHAR(120) NOT NULL,
    TRIGGER_NAME VARCHAR(200) NOT NULL,
    TRIGGER_GROUP VARCHAR(200) NOT NULL,
    STR_PROP_1 VARCHAR(512) NULL,
    STR_PROP_2 VARCHAR(512) NULL,
    STR_PROP_3 VARCHAR(512) NULL,
    INT_PROP_1 INT NULL,
    INT_PROP_2 INT NULL,
    LONG_PROP_1 BIGINT NULL,
    LONG_PROP_2 BIGINT NULL,
    DEC_PROP_1 NUMERIC(13,4) NULL,
    DEC_PROP_2 NUMERIC(13,4) NULL,
    BOOL_PROP_1 VARCHAR(1) NULL,
    BOOL_PROP_2 VARCHAR(1) NULL,
    PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),
    FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
    REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
);

CREATE TABLE QRTZ_BLOB_TRIGGERS
  (
    SCHED_NAME VARCHAR(120) NOT NULL,
    TRIGGER_NAME VARCHAR(200) NOT NULL,
    TRIGGER_GROUP VARCHAR(200) NOT NULL,
    BLOB_DATA BLOB NULL,
    PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),
    FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
        REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
);

CREATE TABLE QRTZ_CALENDARS
  (
    SCHED_NAME VARCHAR(120) NOT NULL,
    CALENDAR_NAME  VARCHAR(200) NOT NULL,
    CALENDAR BLOB NOT NULL,
    PRIMARY KEY (SCHED_NAME,CALENDAR_NAME)
);

CREATE TABLE QRTZ_PAUSED_TRIGGER_GRPS
  (
    SCHED_NAME VARCHAR(120) NOT NULL,
    TRIGGER_GROUP  VARCHAR(200) NOT NULL,
    PRIMARY KEY (SCHED_NAME,TRIGGER_GROUP)
);

CREATE TABLE QRTZ_FIRED_TRIGGERS
  (
    SCHED_NAME VARCHAR(120) NOT NULL,
    ENTRY_ID VARCHAR(95) NOT NULL,
    TRIGGER_NAME VARCHAR(200) NOT NULL,
    TRIGGER_GROUP VARCHAR(200) NOT NULL,
    INSTANCE_NAME VARCHAR(200) NOT NULL,
    FIRED_TIME BIGINT(13) NOT NULL,
    SCHED_TIME BIGINT(13) NOT NULL,
    PRIORITY INTEGER NOT NULL,
    STATE VARCHAR(16) NOT NULL,
    JOB_NAME VARCHAR(200) NULL,
    JOB_GROUP VARCHAR(200) NULL,
    IS_NONCONCURRENT VARCHAR(1) NULL,
    REQUESTS_RECOVERY VARCHAR(1) NULL,
    PRIMARY KEY (SCHED_NAME,ENTRY_ID)
);

CREATE TABLE QRTZ_SCHEDULER_STATE
  (
    SCHED_NAME VARCHAR(120) NOT NULL,
    INSTANCE_NAME VARCHAR(200) NOT NULL,
    LAST_CHECKIN_TIME BIGINT(13) NOT NULL,
    CHECKIN_INTERVAL BIGINT(13) NOT NULL,
    PRIMARY KEY (SCHED_NAME,INSTANCE_NAME)
);

CREATE TABLE QRTZ_LOCKS
  (
    SCHED_NAME VARCHAR(120) NOT NULL,
    LOCK_NAME  VARCHAR(40) NOT NULL,
    PRIMARY KEY (SCHED_NAME,LOCK_NAME)
);


COMMIT;
```



> `以上⼯作准备好之后，重启应⽤，随着前⾯定时任务的执⾏，会⾃动在 QRTZ_CRON_TRIGGERS表插⼊记录!`

![image-20220412222440446](https://pic-go.oss-cn-shanghai.aliyuncs.com/typora-img/202204122224584.png)
