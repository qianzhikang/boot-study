# 统一全局异常处理

## 开发规范

- Conrtoller、Service、DAO层拦截异常转换为自定义异常，不允许将异常私自截留，必须对外抛出。

- 统一数据响应代码、使用http状态码。

- 自定义异常里有message属性，描述异常发生的原因。

- 不允许用父类Exception统一捕获异常，要分类catch。

## 自定义异常的结构

![image-20220411105902050](https://pic-go.oss-cn-shanghai.aliyuncs.com/typora-img/202204111059154.png)

步骤：

1. 定义错误类型枚举
2. 自定义异常
3. 自定义业务逻辑
4. 测试接口
5. 全局异常处理器 @ControllerAdvice



> **定义枚举**

```java
package com.qzk.boot.enums;

/**
 * @Description TODO
 * @Date 2022-04-11-11-29
 * @Author Courage
 */
public enum CustomExceptionType {
    /**
     * 用户输入异常
     */
    USER_INPUT_ERROR(400,"您输入的数据错误！"),
    /**
     * 系统错误
     */
    SYSTEM_ERROR(500,"系统发生错误"),
    /**
     * 系统崩溃了
     */
    OTHER_ERROR(999,"系统崩溃了");

    CustomExceptionType(int code, String desc){
        this.code = code;
        this.desc = desc;
    }

    /**
     * 状态码
     */
    private final int code;
    /**
     * 描述
     */
    private final String desc;
    
    public int getCode(){
        return code;
    }

    public String getDesc(){
        return desc;
    }
}
```



> **自定义异常类**  继承运行时异常。

```java
package com.qzk.boot.exception;

import com.qzk.boot.enums.CustomExceptionType;

/**
 * @Description TODO
 * @Date 2022-04-11-11-42
 * @Author Courage
 */
public class CustomException extends RuntimeException{

    /**
     * 状态码
     */
    private int code;

    /**
     * 错误信息
     */
    private String message;

    private CustomException(){

    }
    
    public CustomException(CustomExceptionType exceptionType){
        this.code = exceptionType.getCode();
        this.message = exceptionType.getDesc();
    }
    
    public CustomException(CustomExceptionType exceptionType,String message){
        this.code = exceptionType.getCode();
        this.message = message;
    }
    
    public int getCode(){
        return code;
    }
    @Override
    public String getMessage(){
        return message;
    }
}
```



> **自定义业务逻辑** （本次的服务类只用于测试，没有实际意义）
>
> 当发生异常时，抛出异常，被全局异常处理类捕获。

```java
package com.qzk.boot.service;

import com.qzk.boot.consts.MsgConsts;
import com.qzk.boot.enums.CustomExceptionType;
import com.qzk.boot.exception.CustomException;
import org.springframework.stereotype.Service;

/**
 * @Description TODO
 * @Date 2022-04-11-12-01
 * @Author Courage
 */
@Service
public class ExceptionService {

    /**
     * 系统异常
     */
    public void systemError(){
        try {
            Class.forName("com.mysql.jdbc.cj.Driver");
        } catch (ClassNotFoundException e) {
            throw new CustomException(CustomExceptionType.SYSTEM_ERROR, MsgConsts.SYSTEM_ERRPR_Message);
        }
    }


    public void userError(int input){
        if (input < 0){
            throw new CustomException(CustomExceptionType.USER_INPUT_ERROR,"输入的数据不符合要求");
        }
    }
}

```



> **全局异常捕获类**
>
> @ControllerAdvice 增强器常用于异常捕获
>
> 使用@ExceptionHandler(CustomException.class)来接住服务类中抛出的异常，进行统一处理。

```java
package com.qzk.boot.handler;

import com.qzk.boot.enums.CustomExceptionType;
import com.qzk.boot.exception.CustomException;
import com.qzk.boot.utils.AjaxResponse;
import org.springframework.stereotype.Controller;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

import java.lang.reflect.Field;

/**
 * @Description TODO
 * @Date 2022-04-11-12-09
 * @Author Courage
 */
@ControllerAdvice
public class WebExceptionHandler {

    @ExceptionHandler(CustomException.class)
    @ResponseBody
    public AjaxResponse customException(CustomException e){
        if (e.getCode() == CustomExceptionType.SYSTEM_ERROR.getCode()){
            //todo 500异常持久化
        }
        return AjaxResponse.error(e);
    }

    
    @ExceptionHandler(Exception.class)
    @ResponseBody
    public AjaxResponse exception(Exception e){
        return AjaxResponse.error(new CustomException(CustomExceptionType.OTHER_ERROR));
    }



    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseBody
    public AjaxResponse handleBindException(MethodArgumentNotValidException e){
        FieldError fieldError = e.getBindingResult().getFieldError();
        assert fieldError != null;
        return AjaxResponse.error(new CustomException(CustomExceptionType.USER_INPUT_ERROR,fieldError.getDefaultMessage()));
    }


    @ExceptionHandler(IllegalArgumentException.class)
    @ResponseBody
    public AjaxResponse handIllegalArgumentException(IllegalAccessException e){
        return AjaxResponse.error(new CustomException(CustomExceptionType.USER_INPUT_ERROR,e.getMessage()));
    }
}

```



> 测试接口

```java
package com.qzk.boot.controller;
import com.qzk.boot.entity.Article;
import com.qzk.boot.service.ExceptionService;
import org.springframework.web.bind.annotation.*;
import javax.annotation.Resource;
import javax.validation.Valid;


/**
 * @Description TODO
 * @Date 2022-04-11-12-22
 * @Author Courage
 */
@RestController
public class ErrorController {
    @Resource
    private ExceptionService exceptionService;

    @GetMapping("/test/{id}")
    public Article test(@PathVariable("id") int id) {
        if (id == 0) {
            exceptionService.systemError();
        }
        exceptionService.userError(id);
        Article article = Article.builder().id(id).title("springboot").build();
        return article;
    }

    @PostMapping("/article")
    public Article saveArticle(@Valid @RequestBody Article article) {
        return article;
    }
}

```

## 统一返回值封装

> 用于返回统一的数据格式，包含状态码、接口信息和数据信息。

```java
package com.qzk.boot.utils;

import com.qzk.boot.exception.CustomException;
import lombok.Data;

/**
 * @Description TODO
 * @Date 2022-04-11-11-54
 * @Author Courage
 */
@Data
public class AjaxResponse {
    /**
     * 状态码
     */
    private Integer code;
    /**
     * 返回信息
     */
    private String message;
    /**
     * 返回数据
     */
    private Object data;

    private AjaxResponse() {

    }

    /**
     * 请求成功的响应，不带返回参数
     * @return AjaxResponse
     */
    public static AjaxResponse success() {
        AjaxResponse ajaxResponse = new AjaxResponse();
        ajaxResponse.setCode(200);
        ajaxResponse.setMessage("请求响应成功");
        return ajaxResponse;
    }

    /**
     * 带返回值的响应成功
     * @param data 返回数据
     * @return AjaxResponse
     */
    public static AjaxResponse success(Object data) {
        AjaxResponse ajaxResponse = new AjaxResponse();
        ajaxResponse.setCode(200);
        ajaxResponse.setData(data);
        ajaxResponse.setMessage("请求响应成功");
        return ajaxResponse;
    }

    /**
     * 请求异常
     * @param e 异常
     * @return AjaxResponse
     */
    public static AjaxResponse error(CustomException e) {
        AjaxResponse ajaxResponse = new AjaxResponse();
        ajaxResponse.setCode(e.getCode());
        ajaxResponse.setMessage(e.getMessage());
        return ajaxResponse;
    }

    /**
     * 请求异常重载
     * @param e 异常
     * @param message 自定义异常信息
     * @return AjaxResponse
     */
    public static AjaxResponse error(CustomException e,String message) {
        AjaxResponse ajaxResponse = new AjaxResponse();
        ajaxResponse.setCode(e.getCode());
        ajaxResponse.setMessage(message);
        return ajaxResponse;
    }
}
```

## 控制器响应类型封住处理

> 将接口控制器中的返回值统一处理并封装成自定义的统一返回值类型

```java
@Component
@ControllerAdvice
public class GlobalResponseAdvice implements ResponseBodyAdvice {
    @Override
    public boolean supports(MethodParameter returnType, Class converterType) {
        return true;
    }

    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) {

        if (selectedContentType.equalsTypeAndSubtype(MediaType.APPLICATION_JSON)) {
            if (body instanceof AjaxResponse ajaxResponse) {
                if (ajaxResponse.getCode() != 999) {
                    response.setStatusCode(HttpStatus.valueOf(ajaxResponse.getCode()));
                }
                return body;
            } else {
                response.setStatusCode(HttpStatus.OK);
                return AjaxResponse.success(body);
            }
        }
        return body;
    }
}
```

## 测试

> 正常返回

![image-20220412143150423](https://pic-go.oss-cn-shanghai.aliyuncs.com/typora-img/202204121431489.png)

> 异常情况1:

![image-20220412143307989](https://pic-go.oss-cn-shanghai.aliyuncs.com/typora-img/202204121433060.png)

> 异常情况2

![image-20220412143417072](https://pic-go.oss-cn-shanghai.aliyuncs.com/typora-img/202204121434127.png)



## 配合实体类校验

上面配置了全局的异常捕获，这里还可以配合实体类的参数校验一起使用，效果更佳

> 添加校验依赖

```xml
 <dependency>
     <groupId>org.hibernate.validator</groupId>
     <artifactId>hibernate-validator</artifactId>
     <version>6.2.0.Final</version>
 </dependency>
```



> 添加实体类的校验规则

![image-20220412143943367](https://pic-go.oss-cn-shanghai.aliyuncs.com/typora-img/202204121439413.png)



> 全局异常捕获中捕获抛出的异常

```java
 @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseBody
    public AjaxResponse handleBindException(MethodArgumentNotValidException e){
        FieldError fieldError = e.getBindingResult().getFieldError();
        assert fieldError != null;
        return AjaxResponse.error(new CustomException(CustomExceptionType.USER_INPUT_ERROR,fieldError.getDefaultMessage()));
    }
```



> 测试接口

```java
 @PostMapping("/article")
    public Article saveArticle(@Valid @RequestBody Article article) {
        return article;
    }
```



### 测试：（仅异常情况）

> id 小于2异常

![image-20220412144136871](https://pic-go.oss-cn-shanghai.aliyuncs.com/typora-img/202204121441914.png)

> 标题为空的异常

![image-20220412144224148](https://pic-go.oss-cn-shanghai.aliyuncs.com/typora-img/202204121442189.png)
