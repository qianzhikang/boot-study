# 服务器推送技术

## 背景与简介

一些页面服务需要实时获取数据更新，如股价的实时更新等，在服务器推送技术出生之前，使用的技术是Ajax轮询，定时的去请求后端服务，给服务器端造成了较大的压力，为了应对这种情况，服务器端需要定时主动往页面推送实时数据。

## 服务器端常用的推送技术

- 全双工通信：WS（WebSocket）

- 服务端主动推送：SSE（Server Send Event）

![image-20220418100858755](https://pic-go.oss-cn-shanghai.aliyuncs.com/typora-img/202204181008838.png)

![image-20220418101236424](https://pic-go.oss-cn-shanghai.aliyuncs.com/typora-img/202204181012466.png)



## 全双工通信 WebSocket

### 兼容HTTPS协议

WebSocket的ws协议：是基于http协议实现的。

WebSocket的wss协议：是基于https协议实现的。

### 全双工数据交互

- onopen     管理连接的建立

- onmessage  管理数据的相互发送

  - 单发

  ![](https://pic-go.oss-cn-shanghai.aliyuncs.com/typora-img/202204181018651.png)

  - 群发

  ![](https://pic-go.oss-cn-shanghai.aliyuncs.com/typora-img/202204181019852.png)

- onclose   管理连接的关闭

- onerror   监听一些通信的异常

### WebSocket整合

> 1. 添加依赖

```xml
<dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter-websocket</artifactId>
</dependency>
```

> 2. 编写socket通信类
>
> `@Opopen`注解的方法表示建立连接时调用
>
> `@OnMessage`注解的方法表示接收前端消息的时候调用
>
> `@OnError`注解的方法表示发生错误的时候调用
>
> `@Onclose`注解的方法表示连接关闭的时候调用
>
> 后端向前端推送消息的时候，可以使用前端连接时唯一的`session`对象的`this.session.getBasicRemote().sendText(message);` 方法进行推送

```java
package com.qzk.boot.socket;

import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import javax.websocket.*;
import javax.websocket.server.ServerEndpoint;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.util.concurrent.CopyOnWriteArraySet;

/**
 * @Description TODO
 * @Date 2022-04-18-10-27
 * @Author Courage
 */
@ServerEndpoint(value = "/websocket") //设置访问的端点，相当于 controller 的
@Component
@Slf4j
@Data
public class MyWebSocket {

    /**
     * 当前在线人数
     */
    private static int onlineCount = 0;

    /**
     * concurrent 包中的线程安全set，用来存放每个客户端对应的MyWebSocket对象
     */
    private static CopyOnWriteArraySet<MyWebSocket> webSocketSet = new CopyOnWriteArraySet<>();

    /**
     * 与某个客户端的链接会话，获取参数，发送数据
     */
    private Session session;


    /**
     * 链接建立成功时调用
     * @param session 会话
     */
    @OnOpen
    public void onOpen(Session session){
        // 为session进行初始化，把当前的session赋值为连接的session
        this.session = session;
        //加入集合
        webSocketSet.add(this);
        //增加在线人数
        addOnlineCount();
        log.info("有新链接加入！当前人数为：" + getOnlineCount());
        String queryString = session.getQueryString();
        String nickname = null;
        try {
            nickname = URLDecoder.decode(queryString.split("=")[1],"UTF-8");
        } catch (UnsupportedEncodingException e) {
            log.error("转码异常");
        }
        log.info(nickname);
        // TODO: 2022/4/18 向客户端发送一条消息：连接成功
        try{
            sendMessage(nickname + "上线了！");
        }catch (IOException e){
            log.error(e.getMessage());
        }
    }


    /**
     * 连接关闭时调用
     */
    @OnClose
    public void onClose(){
        webSocketSet.remove(this);
        subOnlineCount();
        log.info("有链接关闭！当前人数为：" + getOnlineCount());
    }


    /**
     * 接收客户端以后调用的方法
     * @param session 会话
     * @param message 消息
     * @throws IOException io异常
     */
    @OnMessage
    public void onMessage(Session session,String message)throws IOException{
        String queryString = session.getQueryString();
        log.info(queryString);
        String nickname = null;
        try {
            nickname = URLDecoder.decode(queryString.split("=")[1],"UTF-8");
        } catch (UnsupportedEncodingException e) {
            log.error("转码异常");
        }
        log.info(message);
        // TODO: 2022/4/18  进行群发消息
        broadcastInfo(nickname+ " 说：" + message);
    }



    /**
     * 封装基础的发送消息操作
     * @param message 发送的消息
     * @throws IOException io异常
     */
    public void sendMessage(String message) throws IOException{
        //获取基础的远程链接，发送消息
        this.session.getBasicRemote().sendText(message);
    }


    /**
     * 封装群发消息方法
     * @param message
     * @throws IOException
     */
    public static void broadcastInfo(String message){
        for (MyWebSocket item : webSocketSet) {
            try {
                item.sendMessage(message);
            }catch (IOException e){
                log.error(e.getMessage());
            }
        }
    }


    /**
     * 发生错误时调用
     * @param error 异常对象
     */
    @OnError
    public void onError(Throwable error){
        log.error("发生错误", error.getMessage());
        error.printStackTrace();
    }


    //线程方法加锁
    public static synchronized void addOnlineCount(){
        MyWebSocket.onlineCount++;
    }

    public static synchronized void subOnlineCount(){
        MyWebSocket.onlineCount--;
    }

    public static synchronized int getOnlineCount(){
        return onlineCount;
    }
}

```

> 3. 客户端使用socket接收和发送消息
>
> 使用`ws = new WebSocket(`ws://localhost:8888/websocket?nickname=${this.nickname}`)`建立连接；
>
> - `onopen`表示建立连接
> - `onclose`表示连接关闭
> - `onerror`表示发生异常
> - `onmessage`接收推送消息
>
> 使用`ws.send(this.content);`对服务端发送消息

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<div id="app">
    <div>
        <label for="content">
            输入昵称
            <input type="text" v-model="nickname" id="nickname" placeholder="请输入昵称">
        </label>
        <button @click="open()">连接WebSocket</button>
    </div>
    <div>
        <label for="content">
            输入内容
            <input type="text" v-model="content" id="content" placeholder="请输入内容">
        </label>
        <button @click="sendMessage()">发送消息</button>
    </div>
    <div>
        {{message}}
    </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
<script>
    const vm = new Vue({
        el: "#app",
        data() {
            return {
                ws: null,
                nickname: '',
                content: '',
                message: '显示消息',
            }
        },
        methods: {
            open() {
                //创建连接
                ws = new WebSocket(`ws://localhost:8888/websocket?nickname=${this.nickname}`);
                ws.onopen = () => {
                    if (this.nickname === ""){
                        alert("请输入昵称！")
                        return;
                    }
                    console.log("websocket已经连接")
                };
                ws.onclose = () => {
                    console.log("websocket已关闭")
                };
                ws.onerror = () => {
                    console.log("websocket发生异常")
                };
                ws.onmessage = (msg) => {
                    console.log(msg);
                    this.message = this.message.concat(msg.data);
                }
            },
            sendMessage() {
                ws.send(this.content);
                console.log("发送成功");
                this.content = '';

            },
        }
    })
</script>
</body>
</html>
```



## SSE（Server-sent Events） 服务器推送事件

服务器推送事件（Server-sent Events），简称SSE，是 HTML 5 规范中的一个组成部分，可以用来从服务端实时推送数据到浏览器端。相对于与之类似的 COMET 和 WebSocket 技术来说，服务器推送事件的使用更简单，对服务器端的改动也比较小。对于某些类型的应用来说，服务器推送事件是最佳的选择。



### 整合SSE

> 1. 编写控制器
>
> 由于SSE推送的是`事件`,则需要设置返回值类型为`事件流`，即`produces = "text/event-stream;charset=UTF-8"`。
>
> 使用时，需要一个`SseEmitter`对象，调用事件对象的`send()`方法进行数据的推送，接口返回一个`事件流`响应给前端。

```java
@Controller
@Slf4j
public class DemoController {

    @RequestMapping(value = "/server/info",method = {RequestMethod.GET},produces = "text/event-stream;charset=UTF-8")
    public ResponseBodyEmitter pushMsg(){
        SseEmitter emitter = new SseEmitter(0L);
        List<User> list = new ArrayList<>();
        User qzk = User.builder().name("qzk").avatar("https://pic-go.oss-cn-shanghai.aliyuncs.com/avatars/avatar04.jpg").build();
        User lmx = User.builder().name("qzk").avatar("https://pic-go.oss-cn-shanghai.aliyuncs.com/avatars/avatar01.jpg").build();
        list.add(qzk);
        list.add(lmx);
        ObjectMapper mapper = new ObjectMapper();
        try{
            String jsonStr = mapper.writeValueAsString(list);
            emitter.send(jsonStr, MediaType.TEXT_EVENT_STREAM);
        } catch (IOException e) {
            log.error(e.getMessage());
        }
        return emitter;
    }
}
```

> 2. 前端调用
>
> 前端在调用的时候，需要定义一个事件源`let source = new EventSource('http://localhost:8888/server/info');`，然后监听`事件`的几个状态：
>
> - `open` 表示连接
> - `message`表示接收推送
> - `error`时表示连接异常（可能是关闭）
>
> **使用示例**：
>
> ```js
> let source = new EventSource('http://localhost:8888/server/info');
>             source.addEventListener('open', (e) => {
>                 console.log("连接打开")
>             }, false);
>             source.addEventListener('message',  (e) => {
>                 // console.log(e)
>                 this.msg = JSON.parse(e.data)
>             });
>             source.addEventListener('error', (e) => {
>                 if (e.readyState === EventSource.CLOSED) {
>                     console.log("连接关闭");
>                 } else {
>                     console.log(e.readyState);
>                 }
>             })
> ```
>
> 

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>sse</title>
    <style>
        .hover-img {
            background-color: #000;
            color: #fff;
            display: inline-block;
            max-width: 320px;
            min-width: 240px;
            overflow: hidden;
            position: relative;
            text-align: center;
            width: 100%;
            cursor: pointer;
        }

        .hover-img * {
            box-sizing: border-box;
            transition: all .45s ease;
        }

        .hover-img:before,
        .hover-img:after {
            background-color: rgba(0, 0, 0, 0.5);
            border-top: 32px solid rgba(0, 0, 0, 0.5);
            border-bottom: 32px solid raba(0, 0, 0, 0.5);
            position: absolute;
            top: 0;
            bottom: left;
            right: 0;
            content: '';
            transition: all 0.3s ease;
            z-index: 1;
            opacity: 0;
            transform: scaler(2);
        }

        .hover-img img {
            vertical-align: top;
            max-width: 100%;
            backface-visibility: hidden;
        }

        .hoverimh figcaption {
            position: adosolut;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            align-items: center;
            z-index: 1;
            display: flex;
            flex-direction: column•;
            justify-content: center;
            line-height: 1.1em;
            opacity: 0;
            z-index: 2;
            transition-delay: .1s;
            font-size: 20px;
            font-family: sans-serif;
            font-weight: 400;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .hover-img:hover:before,
        hover-img:hover:after {
            transform: scale(1);
            opacity: 1;
        }

        .hover-img:hover>img {
            opacity: 0.7;
        }

        .hover-ima:hover fiacaotion {
            opacity: 1;
        }
    </style>
</head>
<body>
<div id="app">
    <div v-for="(item,index) in msg" style="margin-top: 20px">
        <figure class="hover-img">
        <img :src="item.avatar" />
        <figcaption>
            <h3>{{item.name}}</h3>
        </figcaption>
        </figure>
    </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
<script>
    const vm = new Vue({
        el: "#app",
        data() {
            return {
                msg: '',
            }
        },
        methods: {},
        mounted() {
            let source = new EventSource('http://localhost:8888/server/info');
            source.addEventListener('open', (e) => {
                console.log("连接打开")
            }, false);
            source.addEventListener('message',  (e) => {
                // console.log(e)
                this.msg = JSON.parse(e.data)
            });
            source.addEventListener('error', (e) => {
                if (e.readyState === EventSource.CLOSED) {
                    console.log("连接关闭");
                } else {
                    console.log(e.readyState);
                }
            })
        }
    })
</script>
</body>
</html>
```

