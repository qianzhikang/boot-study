# 嵌入式容器的配置与应用

## SpringBoot支持的应用服务容器

- weblogic

- websphere
- JBoss
- Tomcat
- netty

- jetty

## SpringBoot的application的配置项

server.xx开头是所有servlet容器通用的配置

server.tomcat.xx开头的是tomcat容器特有的配置参数

server.jetty.xx开头的是Jetty容器特有的配置参数

server.undoertow.xx开头的是undertow特有的配置参数

![image-20220408084756673](https://pic-go.oss-cn-shanghai.aliyuncs.com/typora-img/202204080847765.png)

![Snipaste_2022-04-08_08-27-12](https://pic-go.oss-cn-shanghai.aliyuncs.com/typora-img/202204080859080.jpg)



## Tomcat工作原理

- 在Acceptor之前维护一个请求接收队列，该队列的最大长度即：tomcat可以接受的最大请求连接数：servlet.tomcat.max-connections
- Acceptor监听连接请求，并生成一个SocketProcessor任务提交到线程池去处理
- 当线程池里面的所有线程都被占用，新建的SocketProccessor任务被放入等待队列，即server.tomcat.accept-cout
- 线程池的server.tomcat.threads.max决定了tomcat的极限SocketProcessor任务处理能力。不是越大越好，线程越多耗费的资源也越多
- 线程池的server.tomcat.threads.min-spare的应用空闲时，保留一定的线程数在线程池内。避免请求到来后，临时创建线程浪费时间

![lQLPDhtP0OU9xYTNAWTNAtmwBYT9b0Nn8-cCU3GYKMDtAA_729_356](https://pic-go.oss-cn-shanghai.aliyuncs.com/typora-img/202204081239638.png)

## 为Web容器配置HTTPS

### 如何生成自签名的证书？

在终端输入命令

```bash
keytool -genkeypair -alias selfsigned_localhost_sslserver -keyalg RSA -keysize 2048 -storetype PKCS12 -keystore qzk-ssl-key.p12 -validity 3650

```

生成如证书

![image-20220409201642713](https://pic-go.oss-cn-shanghai.aliyuncs.com/typora-img/202204092016833.png)

## 使用：

1. 将生成的证书文件放在项目根目录下

![image-20220409201952288](https://pic-go.oss-cn-shanghai.aliyuncs.com/typora-img/202204092019329.png)

2. 在yml下进行证书的配置：

```yml
server:
  port: 8888
  httpPort: 80
  ssl:
    key-store: qzk-ssl-key.p12
    key-store-password: '123456'
    key-store-type: PKCS12
```



> 再次访问http://localhost:8080/hello已经访问不了了，需要使用 https



![9f72e020-b6e3-11ec-b869-6de719f909d9.jpg](https://public-cdn-oss.mosoteach.cn/mssvc/chatfiles/2022/04/9f72e020-b6e3-11ec-b869-6de719f909d9.jpg)



> 配置http自动映射到https

```java
package com.qzk.boot.config;

import org.apache.catalina.Context;
import org.apache.catalina.connector.Connector;
import org.apache.tomcat.util.descriptor.web.SecurityCollection;
import org.apache.tomcat.util.descriptor.web.SecurityConstraint;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;
import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @description: Tomcat配置类——实现把http请求转发到https
 * @author: qzk
 * @date: 2022-04-08
 **/
@Configuration
public class TomcatCustomizer {

    @Value("${server.httpPort}")
    private int httpPort;

    @Value("${server.port}")
    private int httpsPort;


    @Bean
    public ConfigurableServletWebServerFactory configurableServletWebServerFactory() {
        TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory() {
            @Override
            protected void postProcessContext(Context context) {
                SecurityConstraint constraint = new SecurityConstraint();
                constraint.setUserConstraint("CONFIDENTIAL");
                SecurityCollection collection = new SecurityCollection();
                collection.addPattern("/*");
                constraint.addCollection(collection);
                context.addConstraint(constraint);
            }
        };
        ;
        factory.addAdditionalTomcatConnectors(connector());
        //这里填充配置
        return factory;
    }


    public Connector connector() {
        Connector connector = new Connector("org.apache.coyote.http11.Http11NioProtocol");
        connector.setScheme("http");
        //Connector监听的http的端口号
        connector.setPort(httpPort);
        connector.setSecure(false);
        //监听到http的端口号后转向到的https的端口号
        connector.setRedirectPort(httpsPort);
        return connector;
    }

}
```

